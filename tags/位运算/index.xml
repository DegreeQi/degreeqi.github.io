<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>位运算 on DegreeQi</title>
    <link>https://degreeqi.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
    <description>Recent content in 位运算 on DegreeQi</description>
    <image>
      <title>DegreeQi</title>
      <url>https://degreeqi.github.io/images/papermod-cover.png</url>
      <link>https://degreeqi.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.140.2</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 30 Dec 2024 23:50:00 +0800</lastBuildDate>
    <atom:link href="https://degreeqi.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【算法】Brian Kernighan算法</title>
      <link>https://degreeqi.github.io/posts/%E7%AE%97%E6%B3%95-briankernighan%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 30 Dec 2024 23:50:00 +0800</pubDate>
      <guid>https://degreeqi.github.io/posts/%E7%AE%97%E6%B3%95-briankernighan%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Brian Kernighan 算法&lt;/strong&gt;是指通过将整数 n 与 n-1 进行按位与操作 (n &amp;amp; (n-1))，可以消除 n 二进制表示中最右侧的一个 1。&lt;/p&gt;
&lt;p&gt;延申有 n &amp;amp; (~n + 1)提取出整数n最后一位为1的数，如：n: 01101，~n 是将n按位取反就是10010，~n + 1: 10011，最后，n &amp;amp; (~n + 1): 00001&lt;/p&gt;
&lt;h2 id=&#34;338-counting-bitshttpsleetcodecnproblemscounting-bits&#34;&gt;&lt;a href=&#34;https://leetcode.cn/problems/counting-bits/&#34;&gt;338. Counting Bits&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，对于 &lt;code&gt;0 &amp;lt;= i &amp;lt;= n&lt;/code&gt; 中的每个 &lt;code&gt;i&lt;/code&gt; ，计算其二进制表示中 &lt;strong&gt;&lt;code&gt;1&lt;/code&gt; 的个数&lt;/strong&gt; ，返回一个长度为 &lt;code&gt;n + 1&lt;/code&gt; 的数组 &lt;code&gt;ans&lt;/code&gt; 作为答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：n: 2
输出：[0,1,1]
解释：
0 &amp;ndash;&amp;gt; 0
1 &amp;ndash;&amp;gt; 1
2 &amp;ndash;&amp;gt; 10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最直观的做法是对从 0 到 n 的每个整数直接计算「一比特数」。每个 int 型的数都可以用 32 位二进制数表示，只要遍历其二进制表示的每一位即可得到 1 的数目。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
