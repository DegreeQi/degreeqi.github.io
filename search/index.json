[{"content":"Oneness是一个简洁的Typora主题。\nOneness主题 目前该项目实现了日、夜两个主题，色彩偏好为蓝色，可通过修改./oneness-[theme neme].css中的变量来快速自定义一些简单参数。\nOneness-Light Oneness-Night [!important]\n该主题目前只在Windows平台上进行了测试，测试Typora版本为1.9.5。\nMarkdown编辑区域 Oneness-Light Oneness-Night Typora软件界面 侧边栏 文件树 文件列表 大纲 一体化菜单 一体化菜单 鸣谢 本项目使用了以下开源项目的成果：\nMdmdt by cayxc (Apache-2.0) 使用了其大纲部分的代码，并参考这一部分完成了文件树的数枝效果。 使用了其代码高亮CodeMirror部分的代码。 ","date":"2025-01-02T10:44:19+08:00","permalink":"https://degreeqi.github.io/p/oneness%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84typora%E4%B8%BB%E9%A2%98/","title":"Oneness，一个简单的Typora主题"},{"content":"判断链表中是否有环 判断给定的链表中是否有环。如果有环则返回true，否则返回false。\n双指针 使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。\nhash 1 2 3 4 5 6 7 8 9 10 11 public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null) { slow = slow.next; fast = fast.next; if (fast == null) return false; else fast = fast.next; if (slow.equals( fast)) return true; } return false; } 链表中环的入口结点 给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。\n数学 通过定义slow和fast指针，slow每走一步，fast走两步。若是有环，则一定会在环的某个结点处相遇。（slow == fast）\n假设从头节点到环的入口节点的前一个节点一共有a个，环中的节点有b个，设fast指针走过的节点数是f，slow指针走过的节点数是s，那么有以下两个结论：\n$ f = 2s $ （即快指针走过的节点数一定是慢指针的两倍） $ f = s + nb $ （当两者相遇时，快指针一定已经绕环走了n圈） 即，$ f = 2nb $， $s = nb$\n故可知，两指针相遇时，慢指针已经走了nb步，已知我们要走到入口节点，需要走a+kb步，而这时s=nb，只要再走a步即可到达入口。换言之，从相遇处到入口结点的距离与头结点与入口结点的距离相同。\n或者，对slow而言，它和fast的间距为r-x。也就是说，相遇时slow已走完r-x步，回到入口的距离为x。\n故我们把快指针移动到头节点，速度减少为1，满指针不变。当它们相遇时所处的位置就是入口节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public ListNode EntryNodeOfLoop(ListNode pHead) { ListNode slow = pHead, fast = pHead; while (fast != null) { slow = slow.next; fast = fast.next; if (fast == null) return null; else fast = fast.next; if (slow.equals(fast)) { fast = pHead; while (!fast.equals(slow)) { slow = slow.next; fast = fast.next; } return slow; } } return null; } 两个链表的第一个公共结点 输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）\n双指针1 对于两个链表的问题，首先想到双指针的方法。在这道题中，两个链表长度不一定相等，不能直接使用双指针，我们需要在长链表上先移动一段距离，再进行比较。因为公共部分肯定在链表后面部分，所以不需要担心这一操作导致跳过了第一个公共结点。\n双指针2 对于两个链表长度不一定相等的问题，有没有什么办法可以将两个链表长度对齐呢？ 假设链表1的长度为a，链表2的长度为b，无论a是否等于b，a+b恒等于b+a。由此，我们可以考虑将两个链表拼接起来，再使用双指针。\n1 2 3 4 5 6 7 8 public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { ListNode l1 = pHead1, l2 = pHead2; while(l1 != l2){ l1 = (l1==null)?pHead2:l1.next; l2 = (l2==null)?pHead1:l2.next; } return l1; } ","date":"2024-12-30T23:55:16+08:00","permalink":"https://degreeqi.github.io/p/%E7%AE%97%E6%B3%95%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8/","title":"[算法]有环链表"},{"content":"01背包 已知一个背包最多能容纳体积之和为v的物品 现有 n 个物品，第 i 个物品的体积为 v[i] , 重量为 w[i] 求当前背包最多能装多大重量的物品?\n回溯法 每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。\n动态规划 显然暴力法指数级的空间复杂度是不可接受的，下面使用动规简化为O(VN)\n定义dp[]\n使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。\n确定递推公式\n发现有两种推出dp[i][j]的方向：\n由dp[i-1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i-1][j] 由dp[i-1][j-weight[i]]推出，dp[i-1][j-weight[i]] 为背包容量为j-weight[i]的时候不放物品i的最大价值，那么dp[i-1][j-weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$\n初始化dp[]\n从dp的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。 观察递推公式，发现必须初始化i为0的时候的值。即：存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 为获得最大值，其他下表初始化为最小值（小于正整数），即0。\n确定遍历顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public int knapsack (int V, int n, int[][] vw) { // 定义dp int[][] dp = new int[n][V + 1]; // 初始化dp for (int j = 0; j \u0026lt;= V; ++j) { dp[0][j] = vw[0][0] \u0026lt;= j ? vw[0][1] : 0; } // 递推与遍历 for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= V; ++j) { if (j \u0026lt; vw[i][0]) dp[i][j] = dp[i-1][j]; else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - vw[i][0]] + vw[i][1]); } } return dp[n - 1][V]; } a1 空间优化 dp[i]的结果依赖于dp[i-1]，能否只使用一个数组表示这两个值？ 答案是可以，可以发现dp[i][j]实际上只使用了上一行的较小下标的值。在原思路中j=1···V的顺序会覆盖上一行较小下标，但逆向遍历可以避免这种情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public int knapsack (int V, int n, int[][] vw) { int[] dp = new int[V + 1]; for (int j = 0; j \u0026lt;= V; ++j) { dp[j] = vw[0][0] \u0026lt;= j ? vw[0][1] : 0; } for (int i = 1; i \u0026lt; n; ++i) { for (int j = V; j \u0026gt; 0; --j) { if (!(j \u0026lt; vw[i][0])) dp[j] = Math.max(dp[j], dp[j - vw[i][0]] + vw[i][1]); } } return dp[V]; } a2 一个常数优化 由于只需要最后dp[V]的值，倒推前一个物品，其实只要知道dp[V-w[n]]即可。以此类推，对以第j个背包，其实只需要知道到dp[V-sum{w[j..n]}]即可。\n","date":"2024-12-30T23:54:56+08:00","permalink":"https://degreeqi.github.io/p/%E7%AE%97%E6%B3%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","title":"[算法]背包问题"},{"content":"Brian Kernighan 算法是指通过将整数 n 与 n-1 进行按位与操作 (n \u0026amp; (n-1))，可以消除 n 二进制表示中最右侧的一个 1。\n延申有 n \u0026amp; (~n + 1)提取出整数n最后一位为1的数，如：n = 01101，~n 是将n按位取反就是10010，~n + 1 = 10011，最后，n \u0026amp; (~n + 1) = 00001\n338. Counting Bits 给你一个整数 n ，对于 0 \u0026lt;= i \u0026lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。\n示例：\n输入：n = 2 输出：[0,1,1] 解释： 0 \u0026ndash;\u0026gt; 0 1 \u0026ndash;\u0026gt; 1 2 \u0026ndash;\u0026gt; 10\n最直观的做法是对从 0 到 n 的每个整数直接计算「一比特数」。每个 int 型的数都可以用 32 位二进制数表示，只要遍历其二进制表示的每一位即可得到 1 的数目。\nBrian Kernighan 算法 利用 Brian Kernighan 算法，可以在一定程度上进一步提升计算速度。Brian Kernighan 算法的原理是：对于任意整数 ，令$x=x \u0026amp;(x－1)$，该运算将的二进制表示的最后一个1变成0。因此，对 重复该操作，直到 x 变成0，则操作次数即为的「一比特数」。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; for (int i = 0; i \u0026lt;= n; ++i) { bits[i] = brian(i); } return bits; } int brian(int x) { int one = 0; while (x \u0026gt; 0) { x = x \u0026amp; (x - 1); one++; } return one; } } 动态规划 最高有效位 当计算 i 的「一比特数」时，如果存在 0 ≤ j \u0026lt; i，j 的「一比特数」已知，且 i 和 j 相比，i 的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。\n令 bits[i] 表示 i 的「一比特数」，则上述关系可以表示成：$bits[i]=bits[j]+1$\n下取 2 的幂次方作为j\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; int highBit = 0; for (int i = 1; i \u0026lt;= n; i++) { if ((i \u0026amp; (i - 1)) == 0) { highBit = i; } bits[i] = bits[i - highBit] + 1; } return bits; } } 最低有效位 上述需要实时维护最高有效位，当遍历到的数是 2 的整数次幂时，需要更新最高有效位。如果再换一个思路，可以使用「最低有效位」计算「一比特数」。\n对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，可知：$bits[x]=bits[x\u0026raquo;1]+(x \u0026amp; 1)$\n1 2 3 4 5 6 7 8 9 class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { bits[i] = bits[i \u0026gt;\u0026gt; 1] + (i \u0026amp; 1); } return bits; } } 最低设置位 定义正整数 x 的「最低设置位」为 x 的二进制表示中的最低的 1 所在位。例如，10 的二进制表示是 $1010_{(2)}$，其最低设置位为 2，对应的二进制表示是 $10_{(2)}$。\n令 $y=x~\u0026amp;(x-1)$，则 y 为将 x 的最低设置位从 1 变成 0 之后的数，因此对任意正整数 x，都有 $\\textit{bits}[x]=\\textit{bits}[x\u0026amp;~(x-1)]+1$\n1 2 3 4 5 6 7 8 9 class Solution { public int[] countBits(int n) { int[] bits = new int[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { bits[i] = bits[i \u0026amp; (i - 1)] + 1; } return bits; } } 201. Bitwise AND of Numbers Range 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。\n最直观的解决方案就是迭代范围内的每个数字，依次执行按位与运算，得到最终的结果。但此方法在 范围较大的测试用例中会因超出时间限制而无法通过，因此我们需要另寻他路。\n我们可以发现，对所有数字执行按位与运算的结果是所有对应二进制字符串的公共前缀再用零补上后面的剩余位。进一步来说，所有这些二进制字符串的公共前缀也即指定范围的起始和结束数字 m 和 n 的公共前缀。因此，最终我们可以将问题重新表述为：给定两个整数，我们要找到它们对应的二进制字符串的公共前缀。\n位移 将两个数字不断向右移动，直到数字相等，即数字被缩减为它们的公共前缀。然后，通过将公共前缀向左移动，将零添加到公共前缀的右边以获得最终结果。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int rangeBitwiseAnd(int m, int n) { int shift = 0; // 找到公共前缀 while (m \u0026lt; n) { m \u0026gt;\u0026gt;= 1; n \u0026gt;\u0026gt;= 1; ++shift; } return m \u0026lt;\u0026lt; shift; } } Brian Kernighan 算法 对于给定的范围 [m,n]（m\u0026lt;n），我们可以对数字 n 迭代地应用上述技巧，清除最右边的 1，直到它小于或等于 m，此时非公共前缀部分的 1 均被消去。因此最后我们返回 n 即可。\n1 2 3 4 5 6 7 8 9 class Solution { public int rangeBitwiseAnd(int m, int n) { while (m \u0026lt; n) { // 抹去最右边的 1 n = n \u0026amp; (n - 1); } return n; } } ","date":"2024-12-30T23:50:00+08:00","permalink":"https://degreeqi.github.io/p/%E7%AE%97%E6%B3%95brian-kernighan%E7%AE%97%E6%B3%95/","title":"[算法]Brian Kernighan算法"},{"content":"[toc]\nMarkdown 示例文档 标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 文本 这是一般样式， 这是斜体样式， 这是加粗样式， 这是斜体加粗样式， 这是超链接样式， 这是简单代码样式， ==这是高亮样式，== 这是删除线样式， 这是1样式， 这是下划线样式， 这是键盘样式， 这是^上标^下标样式，\n引用 这是引用文本框，\n这是嵌套的引用文本框，\n以下是Github警告框：\n[!NOTE] 这是一条笔记信息，\n[!TIP] 这是一条提示信息，\n[!IMPORTANT] 这是一条关键信息，\n[!WARNING] 这是一条紧急信息，\n[!CAUTION] 这是一条建议信息。\n列表 这些是列表样式：\n有序列表元素 有序列表元素 有序列表元素 有序列表元素（第二层） 有序列表元素（第三层） 无序列表元素\n无序列表元素\n无序列表元素\n无序列表元素（第二层） 无序列表元素（第三层） 完成\n待做\n代码 这是平方根快速算法的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 float Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = * ( long * ) \u0026amp;y; // evil floating point bit level hacking i = 0x5f3759df - ( i \u0026gt;\u0026gt; 1 ); // what the fuck? y = * ( float * ) \u0026amp;i; y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed return y; } $\\LaTeX$样式 $$ e^{i\\pi}+1=0 $$图片 表格 左对齐 居中对齐 右对齐 一般样式 斜体样式 加粗样式 代码样式 链接样式 ==高亮样式== 删除样式 \u0026hellip; 这是脚注描述样式，\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-12-26T21:00:00+08:00","permalink":"https://degreeqi.github.io/p/test/","title":"Test"}]